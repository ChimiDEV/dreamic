---
id: design
title: Design and Usage
sidebar_label: Design and Usage
---

import Link from '@docusaurus/Link';

## What even is Dreamic?

**Dreamic** (Dream + Atomic) is a utility library designed for functional programming in JavaScript.
The goal is a easy to use api for working with so called `Monads`.
Worry not, if you've never heard of them before.
This documentation includes a <Link to="/blog/2020/09/05">quick practical introduction</Link> as well as some references to other learning sources.  
For now: **Let's just say, they'll be the reason for a better sleep at night.**

Base of Dreamic (hence the name) is an atomic approach in function design and [Fantasy-Land](https://github.com/fantasyland/fantasy-land) aka. the "Algebraic JavaScript Specification".
While reading the documentation, you'll see that the mantra is _composition over all-in-one solutions_.
Heavily inspired by `ramda`, `lodash/fp` and other libraries, **Dreamic will help you keep your code simple, clean, expressive and pure.**

## Usage

Every available monad by Dreamic comes with a specified way of creating and interacting with each.
For easier usage all of them will **share** common functionalities, which will be described below.
Otherwise there may exist some additionally functions specific to a monad. But don't worry, that will be documented.

However since you may wonder how this _common functionality_ might look like, here is little introduction:

### Factory Functions

A monad comes with a set of factory functions.
This will usually be just the name prefixed with **f**, i.e. `f[MonadName]` (obviously you can rename the import the way you want).
If for any reason a monad combines different characteristics (e.g. a **Maybe** being **'Just'** or **'Nothing'**), each of them will be offering their own factory function.

Since monads come with different features and use cases, the factory function footprint and outcome might differ from monad to monad.
For example while a **Maybe** factory has following signature:  
`fMaybe:: a -> a -> Maybe a | maybe(defaultValue, optionalValue)`  
The factory function of **Either** does look like:  
`fEither:: (() -> a) -> Either e a | either(throwingFunction)`

So if you're using a factory function make sure to refer to the documentation of the respective monad.

### Static Methods

Monads do expose a "static method"-like namespace, this will be export simply as the name of the monad all lowercase.
This instance is helpful for some point-free (see below) utility as well, hence the decision to take the name als exported keyword.
Obviously most static functions are specific to each monad himself, however some functions are available through **Fantasy-Land**.
For example `of` ([Applicative](https://github.com/fantasyland/fantasy-land#applicative)) is another way to create a new monad from a value.

### Customized Creation of Monads

The last alternative for creating a monad is not a shared feature over every monad.
Some monads do come with specifically created functions to create a monad.
Since this depends on the type of the monad you're working with, you'll have to look up the documentation.

## Point-free notation
